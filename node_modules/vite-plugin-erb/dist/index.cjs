"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => ErbPlugin
});
module.exports = __toCommonJS(src_exports);
var import_querystring = require("querystring");
var import_path = require("path");
var import_url = require("url");
var import_fs = require("fs");
var import_execa = __toESM(require("execa"), 1);
var import_debug = __toESM(require("debug"), 1);
var import_meta = {};
var debug = (0, import_debug.default)("vite-plugin-erb");
var _dirname = typeof __dirname === "undefined" ? (0, import_path.dirname)((0, import_url.fileURLToPath)(import_meta.url)) : __dirname;
var outputDelimiter = "__VITE_ERB_RESULT__";
var renderedOutputRegex = new RegExp(`${outputDelimiter}([\\s\\S]*?)${outputDelimiter}`, "m");
var rendererPath = (0, import_path.join)(_dirname, "../src/renderer.rb");
function detectRunner(root) {
  try {
    (0, import_fs.accessSync)((0, import_path.join)(root, "bin/rails"));
    return "ruby bin/rails runner";
  } catch {
    return "ruby";
  }
}
async function renderErbFile(cwd, filename, code, options) {
  const { engine = "", runner = "", env, ...execOptions } = options;
  const path = (0, import_path.relative)(cwd, filename);
  try {
    const [cmd, ...cmdArgs] = runner.split(" ");
    const args = [...cmdArgs, rendererPath, outputDelimiter, engine].filter((x) => x);
    debug(`rendering ${path}`);
    const { stdout } = await (0, import_execa.default)(cmd, args, { input: code, cwd, env: { DISABLE_SPRING: "1", ...env }, ...execOptions });
    const matches = stdout.match(renderedOutputRegex);
    if (!matches)
      throw new Error(`No output when rendering ${filename}. Is the file valid?`);
    debug(`rendered ${path}`);
    return matches[1];
  } catch (error) {
    debug(`failed to render ERB file ${path}`, error);
    throw error;
  }
}
function parseId(id) {
  const [filename, rawQuery] = id.split("?", 2);
  const query = (0, import_querystring.parse)(rawQuery);
  if (query.erb !== void 0 || filename.endsWith(".erb"))
    query.erb = true;
  return { filename: filename.split(".erb")[0], query };
}
function ErbPlugin(options = {}) {
  let root;
  let plugins;
  return {
    name: "erb-plugin",
    enforce: "pre",
    configResolved(config) {
      plugins = config.plugins.filter((p) => p.name !== "vite:import-analysis");
      root = process.env.VITE_RUBY_ROOT || config.root;
      if (!options.runner)
        options.runner = detectRunner(root);
      debug(`running renderer with '${options.runner}'`);
    },
    async transform(code, id, ssr) {
      var _a;
      const { filename, query } = parseId(id);
      if (!query.erb)
        return;
      code = await renderErbFile(root, `${filename}.erb`, code, options);
      for (const plugin of plugins) {
        const result = await ((_a = plugin.transform) == null ? void 0 : _a.call(this, code, filename, ssr));
        if (result)
          code = typeof result === "object" ? result.code || "" : result;
      }
      return code;
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
